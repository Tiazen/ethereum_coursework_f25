## Компоненты проекта

## Контракт задеплоил в sepolia, в проекте по умолчанию используется он
https://sepolia.etherscan.io/address/0x1128BdaDdf8717319BBf6086d70455B0b99ce9ef

Есть небольшая задержка на выполнении транзакции конечно

## Технический стек

- **Frontend**: React, TypeScript, Vite, Ethers.js
- **Blockchain**: Solidity, Foundry, Ethereum
- **Backend SDK**: Python 3
- **Пример сервера**: FastAPI

## Структура проекта

```
eth-oauth/
├── frontend/          # Браузерное расширение
├── on_chain/         # Смарт-контракты
├── python_sdk/       # Python библиотека для проверки токенов
└── example/          # Пример веб-сервера
```


### 1. Браузерное расширение (Frontend)
- **Технологии**: React, TypeScript, Vite
- **Функции**:
  - Подключение Ethereum-кошелька
  - Создание и разблокировка хранилища (vault) с мастер-паролем
  - Сохранение, просмотр и удаление учетных данных для разных сайтов
  - Генерация JWT-токенов для аутентификации
  - Автоматическое заполнение форм на веб-страницах
  - Подтверждение запросов на вход от веб-сайтов

### 2. Смарт-контракт (On-chain)
- **Технологии**: Solidity, Foundry
- **Контракт**: `UserVault.sol`
- **Функции**:
  - Хранение зашифрованных учетных данных для каждого пользователя
  - Управление списком сайтов, для которых сохранены данные
  - События (events) для отслеживания операций с данными
  - Доступ к данным только для владельца (через `msg.sender`)

### 3. Python SDK
- **Назначение**: Библиотека для веб-серверов для проверки JWT-токенов
- **Функции**:
  - Парсинг и проверка JWT-токенов
  - Получение публичного ключа пользователя из блокчейна
  - Проверка подписи токена с использованием криптографии Ed25519
  - Проверка срока действия токена и других параметров

### 4. Пример использования (Example)
- **Технологии**: FastAPI, Python
- **Демонстрация**: Пример веб-сервера, который принимает JWT-токены и проверяет их через SDK

## Как запустить
### Браузерное расширение (Frontend)

1. Откройте браузер и перейдите в режим разработчика расширений:
   - **Firefox**: `about:debugging#/runtime/this-firefox`
2. Включите "Режим разработчика"
3. Нажмите "Загрузить распакованное расширение" и выберите папку `frontend/dist/manifest.json`

## Как это работает

1. **Регистрация пользователя**:
   - Пользователь устанавливает браузерное расширение
   - Подключает Ethereum-кошелек
   - Создает хранилище с мастер-паролем
   - Система генерирует пару криптографических ключей (Ed25519)
   - Приватный ключ шифруется мастер-паролем и сохраняется в смарт-контракте
   - Публичный ключ также сохраняется в контракте

2. **Сохранение учетных данных**:
   - Пользователь вводит логин и пароль для сайта
   - Данные шифруются мастер-ключом (AES)
   - Зашифрованные данные сохраняются в смарт-контракте

3. **Аутентификация на сайте**:
   - Веб-сайт отправляет запрос на вход через расширение
   - Пользователь подтверждает запрос
   - Расширение генерирует JWT-токен, подписанный приватным ключом
   - Токен содержит информацию о сайте, имени пользователя и адресе кошелька
   - Токен отправляется на сайт через callback URL

4. **Проверка токена на сервере**:
   - Сервер получает JWT-токен
   - Используя Python SDK, сервер получает публичный ключ пользователя из блокчейна
   - Проверяет подпись токена и его срок действия
   - Если все проверки пройдены, пользователь аутентифицирован

## Структуры данных

### VaultData (Метаданные хранилища)
Хранится в смарт-контракте под специальным ключом `__VAULT_DATA__`:

```typescript
{
  salt: string;                    // Соль для PBKDF2 (16 байт, base64)
  passwordHash: string;            // Хеш мастер-пароля (base64)
  encryptedPrivateKey: string;    // Зашифрованный приватный ключ Ed25519 (AES-GCM, base64)
  privateKeyIV: string;           // Вектор инициализации для шифрования приватного ключа (12 байт, base64)
  publicKey: string;               // Публичный ключ Ed25519 (hex, 64 символа)
  version: number;                // Версия формата хранилища
}
```

**Важно**: `__VAULT_DATA__` — это специальный служебный ключ, который используется для хранения метаданных хранилища пользователя. Он не отображается в списке сайтов и содержит критически важную информацию для работы системы (публичный ключ для проверки JWT-токенов и зашифрованный приватный ключ).

### StoredCredential (Учетные данные)
Структура учетных данных перед шифрованием:

```typescript
{
  website: string;        // URL или домен сайта
  username: string;       // Имя пользователя/логин
  password: string;       // Пароль
  notes?: string;         // Дополнительные заметки (опционально)
  createdAt: number;      // Время создания (timestamp)
  updatedAt: number;      // Время последнего обновления (timestamp)
}
```

### EncryptedCredentialData (Зашифрованные данные)
Формат данных, хранящихся в блокчейне:

```typescript
{
  encryptedData: string;  // Зашифрованные учетные данные (AES-GCM, base64)
  iv: string;            // Вектор инициализации (12 байт, base64)
}
```

### JWT Token Structure
Структура JWT-токена для аутентификации:

**Header**:
```json
{
  "alg": "EdDSA",
  "typ": "JWT"
}
```

**Payload**:
```json
{
  "sub": "username",              // Subject - имя пользователя
  "iss": "0x...",                 // Issuer - адрес Ethereum кошелька
  "aud": "example.com",           // Audience - сайт, для которого выдан токен
  "exp": 1234567890,              // Expiration - время истечения (Unix timestamp)
  "iat": 1234567890,              // Issued At - время выдачи
  "website": "example.com"        // Дополнительное поле с сайтом
}
```

**Signature**: Ed25519 подпись заголовка и payload (base64url)

### Структура в смарт-контракте
В контракте `UserVault` данные хранятся в следующем формате:

```solidity
struct Credential {
    string encryptedData;    // JSON строка с EncryptedCredentialData
    uint256 timestamp;       // Время последнего обновления
    bool exists;            // Флаг существования записи
}

mapping(address => mapping(string => Credential)) userCredentials;
mapping(address => string[]) userWebsites;
```

## Безопасность

### Криптографические алгоритмы

#### 1. PBKDF2 для вывода ключа из пароля
- **Алгоритм**: PBKDF2 (Password-Based Key Derivation Function 2)
- **Хеш-функция**: SHA-256
- **Итерации**: 100,000 (защита от брутфорса)
- **Соль**: 16 байт случайных данных (уникальная для каждого хранилища)
- **Назначение**: Преобразование мастер-пароля в криптографический ключ для шифрования данных

#### 2. AES-GCM для шифрования данных
- **Алгоритм**: AES (Advanced Encryption Standard) в режиме GCM (Galois/Counter Mode)
- **Длина ключа**: 256 бит
- **Размер IV**: 12 байт (вектор инициализации)
- **Использование**: 
  - Шифрование приватного ключа Ed25519
  - Шифрование учетных данных (логины/пароли)

#### 3. Ed25519 для цифровой подписи
- **Алгоритм**: EdDSA на кривой Ed25519
- **Использование**: Подпись JWT-токенов для аутентификации

### Механизмы защиты

#### Защита мастер-пароля
1. **Хеширование пароля**: Мастер-пароль никогда не хранится в открытом виде
   - Используется PBKDF2 с 100,000 итерациями для создания хеша
   - Хеш используется только для проверки правильности пароля при разблокировке
   - Сам хеш не позволяет восстановить пароль

2. **Защита приватного ключа**:
   - Приватный ключ Ed25519 шифруется мастер-ключом (выведенным из пароля через PBKDF2)
   - Зашифрованный приватный ключ хранится в блокчейне под ключом `__VAULT_DATA__`
   - Без мастер-пароля невозможно расшифровать приватный ключ
   - Приватный ключ используется только в расшифрованном виде в памяти расширения

#### Защита учетных данных
1. Все логины и пароли шифруются AES-GCM перед сохранением в блокчейн
2. Каждая запись использует свой случайный вектор инициализации

#### Защита JWT-токенов
1. **Цифровая подпись**: Каждый токен подписывается приватным ключом пользователя изз __VAULT__
2. **Проверка на сервере**: Сервер получает публичный ключ из блокчейна и проверяет подпись
3. **Временные ограничения**: Токены имеют срок действия (по умолчанию 1 час)
4. **Привязка к сайту**: Токен содержит информацию о сайте (audience), для которого он выдан
5. **Привязка к кошельку**: Токен содержит адрес кошелька (issuer), что предотвращает подделку

### Особенности `__VAULT_DATA__`

Ключ `__VAULT_DATA__` используется как для хранения метаданных хранилища:

Содержит публичный ключ, необходимый для проверки JWT-токенов. На один кошелек приходится только одна запись `__VAULT_DATA__`.


